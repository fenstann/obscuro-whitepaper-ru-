## Cryptography
В этом разделе рассматриваются различные криптографические методы, используемые в Obscuro.

### Главный Ключ 
Производители процессоров снабжают каждый TEE одним или несколькими ключами, _Ключами Анклава_ (EK). Эти ключи используются для цифровой подписи сообщений и идентификации TEE. Они также используются для шифрования данных, которые может расшифровать только конкретный аппаратный TEE. Для достижения целей единой децентрализованной сети, такой как Obscuro, все TEE должны работать с одним и тем же множеством транзакций, что означает, что все они должны их расшифровывать.

Первый анклав, называемый _Генезис Анклав_, генерирует 256-битный массив случайных байтов под названием Главный Ключ внутри зашифрованного пространства памяти. Он шифрует этот seed с помощью EK и отправляет его в Управляющий Контракт для хранения там, а также хранит его локально на главном сервере.

### Одновременное использование Главного Ключа
После подтверждения своей проверки, последующие ноды получают секретный _Главный-seed_, которые зашифрованы их ключом. Посредником, по которому они получают данные, является Управляющий Контракт с целью обеспечения максимальной доступности данных.

Перед получением общего secret, ноды L2 должны подтвердить, что они запускают корректную версию контракта на работоспособном CPU.

_Примечание: Решение предполагает, что проверка аттестации может быть эффективно реализована как часть Управляющего Контракта. Это идеальное решение, поскольку оно делает контракт корнем доверия для L2 сети._

Последовательность регистрации ноды показана на следующей схеме:
![node registration](./images/node-registration.png)

Нода на L2 использует методику Управляющего Контракта для предоставления своей гарантии, проверяя ее, а после сохраняя запрос. После, другая нода на L2, (которая уже имеет secret ключ в своем анклаве) отвечает обновлением этой записи с общим secret, зашифрованным с помощью открытого ключа нового TEE. Та нода, которая существует на L2 и отвечающая первой, подписанной анклавом, чтобы гарантировать знание secret, впоследствии получает вознаграждение.

_Примечание: Это решает несколько проблем; Управляющий Контракт предоставляет хорошо известную центральную точку для регистрации в сети Ethereum, которая может хранить общий secret L2 в открытом виде с очень высокой доступностью, а существующие ноды на L2 получают компенсацию за свои затраты на инфраструктуру и оплату газа на L1 для подключения новых нод._

### Генерирование Ключей
TEE используют общий secret для генерации дальнейших асимметричных и симметричных ключей, используемых пользователями для шифрования транзакций и самими анклавами для шифрования содержимого роллапов.

Каждый анклав использует эту главную энтропию для детерминированной генерации дополнительных ключей:

1. Пара открытого/закрытого ключа используется в качестве идентификатора сети. Открытый ключ публикуется на L1 и используется клиентами для шифрования подписанных транзакций в Obscuro и обозначается как _Публичный_Ключ_Obscuro_
2. Набор симметричных ключей, используемых TEE для шифрования транзакций, которые будут храниться на L1 блокчейне в роллапах.

_Примечание: При отправке роллапа, каждый анклав подписывает его ключом, содержащимся в его аттестате (_AK)._

### Шифровка Транзакций
Одной из явных целей при разработки Obscuro, является помощь разработчикам приложений в достижении их требований к конфиденциальности, в то же время предоставляя им инструментарий для того, чтобы отучить пользователей использовать приложение для незаконного поведения, такого как отмывание денег.

При развертывании контракта в Obscuro, разработчик должен выбрать один из предопределенных вариантов разглашения:

* _XS_ - 12 секунд (1 блок)
* _S_ - 1 час (3600/12 = 300 блоков)
* _M_ - 1 день (24 * 3600/12 = 7200 блоков)
* _L_ - 1 месяц
* _XL_ - 1 год

_Примечание: Эти периоды считаются в L1 блоках и являются ориентировочными._

Один из этих вариантов выбирается по умолчанию для приложений, которые не указывают его в явном виде. В зависимости от выбранного периода, транзакции, переданные в это приложение, могут быть расшифрованы любым лицом после этой временной задержки.

Протокол детерминировано извлекает 5 симметричных ключей шифрования для каждого роллапа, которые были получены из главного secret, благодаря опции раскрытия текущего счетчика для этой опции и высоты блока, таким образом, что все TEE, владеющие главным secret, могут вычислить один и тот же ключ шифрования.

Например, приложение _FooBar_ имеет параметр раскрытия _M_ (1 день). Alice отправляет транзакцию (зашифрованную с помощью _Открытого_Ключа_Obscuro_) _Tx1_ 1 февраля и еще одну _Tx2_ 2 февраля. Внутри TEE они расшифровываются и выполняются. Когда создается роллап, все транзакции, отправленные приложениям с одинаковой опцией раскрытия, объединяются агрегатором, сжимаются и шифруются с помощью _Ключа_Шифрования_ _(Главный_Ключ, Опция_Раскрытия, Счётчик, Высота_Блока)_.

Массив транзакций формируется путем конкатенации всех зашифрованных интервалов без какого-либо разделения, чтобы предотвратить утечку информации. Затем, отдельно от массива транзакций, создается структура данных, содержащая начальную (индексную) позицию каждого варианта. Эта структура также добавляется к роллапу после шифрования отдельным ключом, который не раскрывается.

Это показано на следующей диаграмме:
![encryption options](./images/encryption-options.png)

_Обратите внимание, что предопределенные периоды раскрытия предпочтительнее, чем выбор каждым приложением собственного периода, так как это упрощает вычисления и количество ключей, которыми необходимо управлять._

### Механизм Раскрытия
Описанный выше механизм гарантирует, что транзакции Obscuro зашифрованы разными ключами, которые могут быть раскрыты независимо друг от друга.

Другой частью головоломки является механизм, контролирующий процесс раскрытия. На высоком уровне, платформе необходим надежный способ измерения времени, который не может быть подстроен злонамеренным владельцем хоста.

Блоки L1 могут быть использованы в качестве надежной меры среднего времени. Правило заключается в том, что после добавления достаточного количества блоков поверх главного блока, включающего роллап с зашифрованными транзакциями, любой пользователь может запросить ключ шифрования и положение транзакций, которые он имеет право просматривать, из TEE любой ноды в Obscuro.

Вредоносный оператор ноды, желающий получить доступ к транзакциям до истечения назначенного времени, может _попытаться ускорить_ время, создав Ethereum форк, при этом, добывая блоки с хорошо подобранными временными метками таким образом, чтобы сложность постоянно снижалась.

Решение этой проблемы простое. TEE'ы Obscuro полностью понимают протокол Ethereum и принимают все блоки L1 как часть протокола POBI, что позволяет им проверить, что блоки действительны, но они не могут знать, связано ли это с основной сетью Ethereum или вредоносным форком, созданным для ускорения времени. Чтобы решить эту проблему, Obscuro жестко кодирует минимальную сложность ниже, чем средняя сложность сети за последний год, но гораздо выше, чем может достичь любое отдельное лицо. Это не позволит оператору ноды ускорить время.

### Криптографические Алгоритмы
Obscuro делает тот же выбор, что и Ethereum, для алгоритмов хэширования и подписи, а также, использует ту же эллиптическую кривую.

Связь с TEE'ами и алгоритмами шифрования пока не определены.

_Примечание: Возможно, существует более эффективный способ достижения тех же высокоуровневых целей, и поэтому, мы рассматриваем различные другие варианты._
