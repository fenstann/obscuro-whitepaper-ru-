# Консенсус под названием Доказательство Включенности Блока
Obscuro uses a novel decentralised round-based consensus protocol based on a fair lottery and synchronisation with the L1, designed explicitly for L2 rollups, called _Proof Of Block Inclusion_ (POBI). It solves, among others, the fair leader election problem, which is a fundamental issue that all decentralised rollup solutions have to address. POBI is inspired by [Proof Of Elapsed Time](https://www.investopedia.com/terms/p/proof-elapsed-time-cryptocurrency.asp).

## Высокоуровневое описание
Высокоуровневые цели POBI протокола таковы:

1. Пытаться каждый раунд справедливо распределять функцию секвенсора между всеми активными зарегистрированными агрегаторами
2. Синхронизировать продолжительность L2 раунда с раундами L1. Поскольку L1 является первоисточником, окончательность транзакций L2 зависит от окончательности включающей их роллап транзакции на L1, что означает, что нет никакого преимущества в публикации нескольких роллапов в одном блоке L1. Невозможно уменьшить время включения ниже, чем у L1, и, с другой стороны, публикация L2 роллапов реже означает, что включение на L2 будет неоправданно долгим. Оптимальной частотой является публикация одного роллапа на блок L1.

Для достижения объективности в протоколе POBI указано, что TEE может генерировать одну случайную одноразовую переменную каждый раунд, а победителем раунда считается тот агрегатор, чей TEE генерирует наименьшее случайное число из группы. TEE генерируют эти числа независимо друг от друга и затем объединяет их. Агрегаторы, которые не выиграли раунд, подобно майнерам на L1, придерживаются этом решению, потому что это рационально, исходя из механизма стимулирования. Если они решают не придерживаться решениям протокола, то их могут обозначить как проигравших раунд на L1, что приведет к игнорированию всеми роллапами Агрегатора, что означает, что такой Агрегатор должен будет оплатить газ на L1 и не получить никакого ценного вознаграждения.

Вторая цель достигается путем связывания генерации одной случайной одноразовой переменной, которая завершает раунд, благодаря доказательству Меркла о включении первоначального роллапа (который существует в L1 транзакции Дерева Патриция) в L1 блок. Это свойство и дало название протоколу. Это означает, что агрегатор может получить подписанный роллап от TEE только в том случае, если он сможет доказать, что роллап опирается на опубликованный роллап в предыдущем блоке L1. Более того, эта функция связывает создание L2-роллапа с L1-блоком, тем самым синхронизируя их частоту.

Сторона, желающая увеличить свои шансы на победу в раундах, должна зарегистрировать несколько Агрегаторов и внести стейк на каждого из них. Величина стейка должна быть рассчитана таким образом, чтобы достичь правильного баланса децентрализации и практичности.

Для всех остальных Агрегаторов не составит труда проверить, какой роллап является победителем, сравнив одну случайную одноразовую переменную и проверив, что подпись роллапа принадлежит утверждённому Агрегатору.

Обратите внимание, что Управляющий Контракт L1 не проверяет одну случайную одноразовую переменную, которую представляют роллапы, но проверяет корректность доказательства включенности блока. Контракт L1 отклоняет роллапы, созданные с использованием доказательства включенности, которые не являются родоначальником текущего блока.

Еще одна проблема, которую необходимо решить, заключается в том, чтобы гарантировать, что хост не сможет повторно отправить доказательство в TEE, чтобы попытаться получить более низкую случайную переменную, как объясняется [здесь](#preventing-repeated-random-nonce-generation).

## Типичные сценарии
1. Новый раунд начинается, с точки зрения Агрегатора, когда он решает, что кто-то объединился с выигрышным роллапом. В этот момент, он создает новую пустую структуру роллапа, связывает ее с предыдущим и начинает добавлять в нее транзакции (которые поступают от пользователей или по взаимосвязи).
2. В это время он внимательно следит за L1, будучи напрямую подключенным к ноде на L1.
3. Как только предыдущий роллап был добавлен к добытому блоку L1, агрегатор задействует доказательство Меркла, передавая его TEE, который отвечает подписанным роллапом, содержащим одну случайную одноразовую переменную, которая сгенерирована внутри анклава.
4. Все остальные агрегаторы делают примерно всё тоже самое в то же время.
5. В этот момент, (который происходит сразу после успешной публикации предыдущего роллапа в L1) каждый агрегатор имеет подписанный роллап со случайным одноразовым числом, которое они передают друг другу. Побеждает сторона с наименьшим одноразовым числом. Все Агрегаторы знают об этом, и после короткого периода ожидания начинается новый раунд.
6. Победивший Агрегатор должен создать транзакцию на Ethereum, которая опубликует этот роллап в L1.

Обратите внимание, что благодаря введению требования о доказательстве включенности в L1, соблюдается периодичность публикации роллапов в блокчейн. Также обратите внимание, что хэш блока L1, используемый для доказательства TEE того, что предыдущий роллап был опубликован, добавляется к текущему роллапу, чтобы Управляющий Контракт и другие агрегаторы знали, правильно ли был сгенерирован этот роллап.

На следующей диаграмме показана данная последовательность:
![node-processing](./images/node-processing.png)

## Условные обозначения
Существует шесть элементов, характеризующих роллап :

1. Первоначальный роллап.
2. Высота роллапа (N-ое поколение).
3. Агрегатор, который его сгенерировал.
4. Высота блока L1, используемого в качестве доказательства (L1_Доказательство_Высоты).
5. Высота блока L1, включающего этот роллап (L1_Высота_Блока).
6. Одноразовое, случайно сгенерированное число.

На следующей диаграмме показаны эти элементы:
![block elements](./images/block-elements.png)

Условные обозначения следующие: _R_$Высота_Роллапа[$Агрегатор, L1_Доказательство_Высоты, L1_Высота_Блока, $Одноразовое_Число].

Обратите внимание, что значение _L1_Доказательство_Высоты_ может быть только меньше, чем _L1_Высота_Блока_.

Пример: _R_15[Alice, 100, 102, 20] означает, что высота роллапа равна 15, агрегатором является _Alice_, высота блока L1, используемого в качестве доказательства, равна 100, высота блока L1, включающего роллап, равна 102, а значение одноразового числа равно 20.

## Основная Цепь
Протокол POBI позволяет любому агрегатору публиковать роллапы в Управляющем Контракте, поэтому малейшие форки являются нормальной частью протокола. Данные форки не могут быть долгоживущими во время нормального функционирования, потому что ObscuroVM, работающая в TEE каждой ноды, детерминированно выбирает один из форков в качестве основная цепи и добавляет роллапы только поверх нее.

Поскольку логика идентична и заверена на каждой ноже, а TEE получает всё релевантное содержимое блоков L1 (что означает, что они обрабатывают одни и те же входные данные), не может быть никаких конкурирующих форков с  глубиной более одного роллапа, если только не произошел взлом.

Правила для основная цепи следующие:
1. Генезис роллап является частью основной цепи и должен быть включен в L1 блок первым агрегатором.
2. Блок L1, содержащий один роллап, родоначальником которого является главный роллап основной цепи, включенный в предыдущий блок L1, находится в основной цепи, если никакой другой роллап с тем же родоначальником не был включен в предыдущий блок. Любой другой роллап, включенный в более поздний блок, не входит в основную цепь. Это правило _Примогенитура_, когда роллап возникает при включении в блок L1.
3. Если блок L1 содержит несколько связанных роллапов, созданных в одном раунде с использованием одного и того же доказательства L1, то в основную сеть включается тот, у которого наменьшее случайное одноразовое число.
4. Если блок L1 содержит несколько связанных роллапов, созданных с использованием разных L1 доказательств, то в основной сети находится тот, который создан с использованием более позднего доказательства.

[comment]: <> ([TODO - diagram depicting these scenarios])

Используя эти обозначения, для одинаковой _Высоты_Роллапа_, роллап на основной цепи - это тот, у которого:

1. Наименьший L1_Сгенерированный_Блок.
2. В случае нескольких совпадений, используйте самое высокое L1_Доказательство_Генерации.
3. В случае нескольких совпадений, используйте наименьшее случайное одноразовое число.

Учитывая, что наименьшее случайное одноразовое число является случайным числом с достаточной энтропией, мы предполагаем, что в этот момент, при нормальном функционировании не может произойти коллизия. В ситуации, когда это произойдет, роллап на основной цепи будет тот, у которого окажется наименьший хэш.

## Предотвращение повторной генерации случайных одноразовых чисел
В третьей фазе протокола, TEE каждого агрегатора генерирует случайное одноразовое число, которое определяет победителя в протоколе. Это создает возможность для игры в систему, путем перезапуска TEE и генерации нескольких чисел.

Решение, предложенное Obscuro, заключается во внедрении таймера в конструктор при каждом запуске анклава. Обычный таймер, основанный на часах компьютера, не очень эффективен, поскольку владелец может его подделать. Вместо этого, анклав должен последовательно (на одном потоке) вычислить достаточно большое количество хэшей формата SHA256, что по теории, он не сможет сделать быстрее среднего времени на блок, даже имея мощное оборудование.

Это решение является эффективным, поскольку код проверен и не зависит от ввода данных от ноды.

Оператор ноды, желающий схитрить, перезапустит анклав и быстро передаст ему доказательство включенности, только для того, чтобы анклав обработал его через 15 секунд, что означает, что оператор уже пропустил временное окно для этого роллапа.

Такая встроенная задержка запуска также полезна для предотвращения других атак через побочные каналы в режиме реального времени, которые могут быть использованы для MEV.

## Стимулы для Агрегаторов

Все успешные децентрализованные решения нуждаются в надежном механизме стимулирования для поддержания эффективного функционирования протокола.

По сравнению с типичными L1 протоколами, здесь есть дополнительная сложность. В протоколе L1, таком как Bitcoin или Ethereum, как только нода взаимодействует с действительным блоком, все остальные ноды получают стимул использовать его в качестве родоначального, потому что они знают, что все так делают. В децентрализованном протоколе L2, таком как POBI, есть дополнительный шаг: публикация роллапа в L1, которая может не состояться по множеству причин. Кроме того, при разработке стимулов, необходимо учитывать проблему опережения актуального роллапа. Чтобы роллап стал окончательным, он должен быть добавлен в блок L1, где майнер или стейкер из L1, может попытаться получить вознаграждение, которое по праву принадлежит другой ноде на L2 .

Обратите внимание, что окончательность роллапа будет подробно рассмотрена в [Взаимодействие Obscuro и Ethereum](./obscuro-ethereum-interaction).

Наивысшая цель состоит в том, чтобы система функционировала как можно более гладко и не допускала случайных сбоев или злонамеренного поведения, не наказывая при этом ноды Obscuro за недоступность. Мы считаем, что штрафы за доступность, повышают барьер входа и, таким образом, централизуют систему в долгосрочной перспективе.

Obscuro вводит концепцию получения вознаграждения независимо от фактической основной цепи роллапа. Большим преимуществом является повышенная гибкость в распределении стимулов, ценой повышенной сложности. Вознаграждение может быть выдано полностью, разделено между агрегаторами или просто выделено для покрытия стоимости газа.

Чтобы достичь этого, протокол должен поддерживать резерв токенов. Пользователи будут вносить плату в этот пул, а ноды будут получать вознаграждение из него. В процессе запуска протокол, появится возможность добавлять в пул новые токены. Когда сеть наберет обороты, протокол сможет сжигать излишки токенов.

Обратите внимание, что важным допущением является то, что вознаграждение от публикации роллапа никогда не превысит удвоенную стоимость газа. Это может быть скорректировано формулами, по которым рассчитываются [вознаграждения](./fees-rewards).

Вот правила для вознаграждения Агрегаторов:

1. Первый Агрегатор, успешно опубликовавший роллап без конкуренции в блоке L1, получит полное вознаграждение. Это наиболее эффективный случай, который поощряется.
_Примечание: Конкуренция подразумевает другой роллап с тем же родоначальником._ 

2. Если в одном блоке (цельном блоке) публикуются несколько роллапов, созданных с одним и тем же доказательством на L1 и разными одноразовыми числами, то в основную цепь попадает роллап с наименьшим одноразовым числом, но вознаграждение делится между ними в пропорции 75/25 (это соотношение только ориентировочное). Причина этого правила заключается в том, что оно стимулирует агрегаторов опубликовывать свой выигрышный роллап так, чтобы никто другой не опубликовал его в то же самое время.
    - У проигравшего Агрегатора нет стимула для публикации, так как 25% вознаграждения не покроют стоимость газа, поэтому он понесет только убытки.
    - У выигравшего агрегатора есть стимул рассказывать о роллапе всем остальным, чтобы избежать этой ненужной конкуренции.
    - В случае настоящего сбоя в передаче информации (т.е. за пределами установленной задержки), проигравший Агрегатор получает хоть что-то. Это делается для того, чтобы уменьшить риск того, что Агрегаторы будут ждать больше, чем необходимо, чтобы получить сообщения от всех других Агрегаторов.


3. Если в один и тот же блок включено несколько родоначальных роллапов, созданных с использованием разных блоков на L1 в качестве доказательств, то роллап, созданный с самым последним доказательством, получает полное вознаграждение. 

     Оригинальный роллап-победитель, который не был опубликован сразу, не получает никакого вознаграждения, поскольку уже существует более свежий роллап. Это правило призвано стимулировать публикацию с высоким количеством газа, чтобы не было риска конкуренции в следующем блоке. Правило также поощряет Агрегаторов не ждать роллапов, опубликованных с недостаточным количеством газа или не опубликованных вовсе. 

     Этот механизм обеспечивает сброс раундов, когда доступны новые блоки на L1, и награда становится актуальной. Лицо, контролирующее несколько Агрегаторов со злонамеренным иррациональным поведением, может только замедлить работу распределённого реестра, потому что рациональные лица будут публиковать роллапы, при которых они выиграли.

4. Если два последовательных L1-блока включают в себя роллап с одинаковой высотой, созданный на основе одного и того же L1 доказательства, но роллап из второго блока имеет более низкое случайное число, разделение вознаграждения происходит поровну между двумя Агрегаторами.

     _Обратите внимание, что роллап с более высоким одноразовым числом, находится на основной цепи._

     Рациональность этого правила заключается в том, что подобный сценарий может быть результатом опережения роллапа, которое, таким образом, не поощряется, поскольку опережающий его расходует драгоценный газ на Ethereum, а вознаграждение, по итогу, всегда будет меньше затрат.

     Равномерное распределение вознаграждения также побуждает агрегатора, выигравшего раунд генерации одноразового числа, публиковать его как можно скорее, поскольку публикация блока позже, в лучшем случае, приведет к небольшим потерям.

5. Если два связанных роллапа, созданных на основе одного и того же доказательства на L1, опубликованы с разницей более чем в один блок, и первый опубликованный роллап имеет более высокое одноразовое число, то вознаграждение полностью выплачивается первому опубликованному роллапу. Причина этого правила в том, что победитель, скорее всего, добавил слишком мало газа, а кто-то другой заметил эту возможность и внес свой вклад для более раннего завершения, за что и получает вознаграждение. Это добавляет стимул следить за ценами на газ и платить достаточно, чтобы их роллап был опубликован.

На следующих диаграммах изображены некоторые из правил для вознаграждения:
![l1 rewarding](./images/block-rewarding.png)

На следующей диаграмме изображены правила в случае опережения:
![l1 front running](./images/block-frontrunning.png)

Это python'о-подобный псевдокод для расчета вознаграждений, которые может потребовать агрегатор за Высоту_Роллапа. Обратите внимание, что он не охватывает всю область, и может существовать множество конкурирующих агрегаторов.

```python
# The rollup height for which we calculate the rewards
height = N

# 'heightN_L1_Blocks' is a list of all L1 blocks starting with the _L1_Block_Height_ of the head 
# of the canonical chain of the previous generation, until the block where you encounter the 
# first valid rollup of _Rollup_Height_ plus one extra L1 block.
heightN_L1_Blocks = calculateBlocks()

# List of rollups of height N found in the last block
rollups_in_last_block = heightN_L1_Blocks[-1].rollups.filter(r.height == height)

# List of rollups of height N found in the target block
rollups_in_target_block = heightN_L1_Blocks[-2].rollups.filter(r.height == height)

if rollups_in_target_block.size == 1 and rollups_in_last_block.size == 0:

    # There is no competition for the target rollup
    fullRewardTo(rollups_in_target_block[0].aggregator)

elif rollups_in_target_block.size == 1 and rollups_in_last_block.size == 1:

    # There is competition for the target rollup in the next rollup
    # Which means there is suspicion of frontrunning
    target_rollup = rollups_in_target_block[0]
    competition_rollup = rollups_in_last_block[0]
   
    if competition_rollup.L1_Proof_Height == target_rollup.L1_Proof_Height and competition_rollup.nonce < target_rollup.nonce:
        # This is possibly front-running or failure to gossip
        # All parties involved in this will make a small loss
        partialRewardTo(target_rollup.aggregator, '50%')
        partialRewardTo(competition_rollup.aggregator, '50%')
    else:
        # The target has the lower nonce or is generated with a different proof
        fullRewardTo(target_rollup.aggregator)

elif rollups_in_target_block.size == 2:
    # Two competing rollups in the target block
    # This is not a front-running situation, so eventual rollups published in the next block do not matter
    rollup1 = rollups_in_target_block[0]
    rollup2 = rollups_in_target_block[1]

    if rollup1.L1_Proof_Height == rollup2.L1_Proof_Height:

        # According to rule #2 the competing rollups will split the reward 
        if rollup1.nonce < rollup2.nonce:
            partialRewardTo(rollup1.aggregator, '75%')
            partialRewardTo(rollup2.aggregator, '25%')
        else:
            partialRewardTo(rollup1.aggregator, '25%')
            partialRewardTo(rollup2.aggregator, '75%')

    elif rollup1.L1_Proof_Height > rollup2.L1_Proof_Height:

        # According to rule #3 the rollup generated with the more recent proof gets the reward 
        fullRewardTo(rollup1.aggregator)
   
    else:
        # According to rule #3 the rollup generated with the more recent proof gets the reward 
        fullRewardTo(rollup2.aggregator)
        
else:
    pass
```

_Обратите внимание, что эти правила могут быть скорректированы на основе производственных наблюдений.._


## Эволюция Роллапов
![block rollup complex](./images/block-rollup-complex.png)
